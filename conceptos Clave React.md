# Conceptos clave de REACT
## Strict Mode
> Es un modo que va a tratar de controlar la manera en que funcionan los componentes, va a ver que todo funcione correctamente, lo que va a hacer es montar un componente, lo va a montar (renderizarlo), lo va a destruir y lo va a volver a cargar y va a verificar que el componente antes de destruirlo, sea igual al que se vuelve a cargar, esta es la razón por la cual, en varias ocasiones como llamados a api, se ve que se duplican los llamados a la API ( En producción se quita )
## Detección de cambios (SPA)
1. **trigger** -> cualquier tipo de evento que inicia un proceso de render
    * ***Trigger inicial:*** Montar (renderizar por primera vez el componente)
    * ***Trigger Re Render*** Re renderizar algo que ya se habia montado
2. **DOM & DOM Virtual:** El DOM es el mismo de js que el que se encarga de controlar lo que se muestra en el cliente usando el HTML, El dom virtual en cambio es un intermedio, donde estan los cambios que estan esperando ser actualizados, REACT, compara las diferencias y estas son luego, montadas en el DOM y renderizadas
    * Los componente en React son **FUNCIONES**, Un render es ejecutar la funcion para  mostrar graficamente el **COMPONENTE**, deben ser la minima unidad logica posible
    * ***COMMIT:***  Cuando REACT, ya relizo la comparación entre el **DOM** y el **Virtual DOM**, el proceso de aplicar un **CAMBIO** y **RENDERIZARLO** , es un ***COMMIT*** 
    * **JSX & TSX:** Es un tipo de archivo donde se encuetran los componentes de react, el bundler espera que de este archivo se exporte, una funcion que tenga logica interna y regrese tambien HTML con logica inscrita en el interior
3. **Logica al programar**
    * Tener una carpeta ***private*** para los modulos que no son accesibles sin autenticación 
    * Tener una carpeta ***Public*** para los modulos que esten abiertos a todo el publico sin necesidad de autenticarse (por ejemplo, Login o Registro)
    * Tener una carpeta Components para los elementos atomicos y tener una carpeta con cada uno donde haya por lo menos ***CSS*** y ***TSX***
    * Un componente debe ser la minima expresión logica posible, si una logica o alguna parte de un componente no pertenece propiamente al componente (Como el texto de un botón) entonces usar props para pasar los valores desde el padre
    * Si un componente, tiene alguna accion, que desde el diseño requiere que el padre pase por props una funcion para su ejecución desde el hijo, **NO HACERLO**, invirte la logica y que el hijo ***EMITA EL EVENTO*** y sea responsabilidad del padre hacerse cargo de ejecutar dicha logica
    * **Regla del barril** En la carpeta de components o otras carpetas que tengan multiples archivos que deban exportarse, en vez de complicar las exportaciones al tener que indicar la ruta exacta de su ubicacion, en la raiz de la carpeta, por ejempli components, se puede tener un archivo index.ts que se encargue de exportar los diferentes componentes que se tengan y de esa manera, la importación de los componentes sera, mucho más sencilla.
4. **Componentes Statefull y Stateless**
    * ***Estado:*** Son las variables de React donde se van a guardar datos, metodos etc, que son utilizados en el TSX y que condicionan el render
        * ***Batching*** En react, es posible encadenar multiple llamadas a un cambio de estado, estas, se dejaran hasta el final y se ejecutaran en orden, pero, **OJO**, aunque se ejecuten todas, no significa que se llame al render por cada una y por ende, si se intenta acumular o utilizar un valor progresivo entre ejecuciones de los estados, no se tendra el resultado deseado, ya que, el valor de un estado, solo se actualiza efectivamente al final de un render, **PERO**, puede pasarse una funcion que reciba dicho estado y actualice el valor, ya que las fuciones no se ejecutan inmediatamente sino que van ejecutandose en el render y permitira, que el efecto esperado acumulativo suceda, ya que el valor del estado actualizado se va pasando de función a función
    * ***Hooks:*** Los hooks, se identifican por que siempre usan **use** al principio, se usa para enganchar algo que tenga que ver con el estado de la aplicacion
        * ***useState:*** Para que se pueda renderizar el cambio en un campo o algun valor dinamico, los cambios no pueden ser almacenados en variables comunes, estas internamente si cambiaran su valor PERO SOLO se llama al render, al cambiar un estado, por lo cual, no se vera reflejado en el cliente si no se usa UseState, no significa, que no se pueda utilizar logica a parte, pero si se requiere un cambio con render, debe actualizarse el valor del estado.
        * ***useEffect:*** Es para ayudar a controlar los ciclos de vida del componente, recibe una funcion donde debe ir la logica del useEffect y un arreglo de dependencias; el hook se ejecuta siempre que haya un cambio, se ejecuta primero, cuando se monta el componente, el orden en este caso seria: (Se monta el componente, se realiza el render, se ejecuta el useEffect por primera vez) y tambien se va a ejecutar siempre, cada vez que se modifique alguno de los **valores (estados)** del arreglo de dependencias (Debe ser Estados (useState)), si no se pasa un arreglo y solo se pasa la funcion del useEffect, hara que se ejecute el useEffect, cuando se actualice cualquier valor del estado del componente. Si se pone un return **(tambien es un metodo)** en la logica del useEffect, esta funcion que se retorna , se va a ejecutar, cuando el componente muera (cuando es destruido), se utiliza para liberar memoria y manejar el estado de la memoria. El uso mas adecuado para el useEffect es sync con entidades externas, incluye tambien, estados que vienen de afuera de la aplicacion (como el padre, parametros de entrada), si se tiene la referencia de una funcion externa en el hook y se agrega al array de referencia, se genera un ciclo infinito porque por cada render, la funcion se volvera a crear y cambiara su estado y por ende se volvera a ejecutar el useEffect, por lo tanto la solucion para este caso son dos: Establecer la funcion dentro del useEffect o  envolver la funcion fuera del hook en otro hook llamado **useCallback**
        * ***useCallback:*** Es una forma de asegurarse que la referencia a un metodo sera siempre la misma, siempre que no cambie algo, se mantiene en memoria, este hook, tambien recibe la funcion y un array de depencias.
        * ***CustomHook:*** Cuando se tenga logica compleja que contenga multiples estados y usos de useEffect por ejemplo, la logica no se realiza en el componente porque compromete el principio de responsabilidad unica y se debe, aislar en una hook generalizado que si es posible, pueda ser reutilizado en demas componentes sin problemas
    * **AbortController:** Al manejar peticiones asyncronas, es importante controlar, que pasa con las peticiones, si el componente se ha destruido, esto, debido a que , aunque el componente se destruye, la peticion sigue existiendo y se sigue esperando respuesta, por lo cual, lo correcto, es crear un AbortController y pasarlo al fetch, para que este controle cuando cancelar una peticion que ya no se esta esperando y es innecesaria
    * ***Pick*** y ***Omit*** son dos funciones de TypeScript, que permiten, elegir, de una referencia de tipo, cuales propieades se van a utilizar de una tipo especificado o cual se debe omitir, por ejemplo , si se tiene una interface Person con los datos {name,age} , se puede hacer Pick<Person, "name"> para solo hacer referencia a una interface persona que tiene nombre y nada mas o tambien se puede usar Omit<Person,"age"> para que la referencia sea un Tipo Person, que no va a tener age, es muy util cuando se tiene un modelo de algo en la logica y se puede usar de distintas maneras y no siempre, vas a necesitar toda la informacion o no se tiene aun toda la información completa.
    * ***Prop drilling:*** Cuando se tienen datos de componentes que se van pasando a traves de props y se genera un alto acoplamiento entre componentes lo que genera que si no existe un componente o no se pasa el contexto a traves del prop, no funcione la aplicacion.
    * ***Service*** Se puede usar servicios para compartir informacion entre componentes, importante, a diferencia de angular, estos no son construidos automaticamente y no son ni injectables ni singleton, asi que debe manejarse casos especiales de manera propia y ademas , recomendable, exportar al final del documento donde se ddefine el servicio, una instancia para usarla tipo singleton en la app, hay que tener en cuenta el problema de condicion de carrera, y es que en algun componente se pida una informacion que aun no existe en el servicio
    * ***Proyecion de contenido*** se puede esperar un children en un componente tipo ReactNode, el cual sera un elemento Jsx que se pasa entre <> </> y se puede directamente pasar un componente que sera luego utilizado en otro componente
    * **Context** Es una via de comunicacion de eventos, para poder utilizarlos, los componentes deben ser envueltos en algun punto por un provider que permita extraer los datos de este contexto
    * **useRef:** No genera re - renderizados, lo hace interno en el componente, toca usar estados para que visualmente se actualicen los valores
        * objetivo 1 => Nos permite crear una referencia **mutable**, que persiste durante todo el ciclo de vida del componente, sin causar un ***Re-render***
          * objetivo 2 => Hacer referencia a un elemento del DOM
    * **useMemo:** Controlar si el beneficio de memorizarlo es superior al de recalcularlo, ***En react 19 ya es automatico***
     *  objetivo 1 => Memorizar (crear cache) el resultado de ejecutar una función costosa, para evitar que se vuelta a llamar el método
    * **memo** Es posible envolver un componente en memo y esto permitira, almacenar en cache, el componente y si sus props no han cambiado, entonces, no se realizara el re -render (osea, permite skipear la redederizacion si no es necesario actualizar el componente)
    * **Portal** Es Ubicar un componente de JSX en cualquier punto que se desee de la aplicación
    * **Error boundary** Es posible con React tener un control mas detallado de los errores en ejecucion de los componentes y controlar el curso de accion o la pantalla a mostrar, solo reconoce errores durante el renderizado
    * **React Router:** Puede instalarse con el comando ***npm i react-router-dom***
        * Se aconseja crear dos carpetas, una carpeta public, para aquellos elementos sin validación de identidad para su acceso y una carpeta private, para paginas protegidas y requieran autorización 
        * ***BrowserRouter***  Es un router que se utiliza en buscadores web, provee las rutas que iran en una aplicacion Web
